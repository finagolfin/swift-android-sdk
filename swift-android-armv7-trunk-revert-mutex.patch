From 2a60c88457d593ed97c7eccf2bc588cbbbdddbc2
From: Alejandro Alonso <alejandro_alonso@apple.com>
Date: Sun, 4 Feb 2024 23:57:16 -0800
Subject: Implement Mutex in Synchronization

diff --git a/swift/stdlib/cmake/modules/AddSwiftStdlib.cmake b/swift/stdlib/cmake/modules/AddSwiftStdlib.cmake
index ca3e94dfc669c..e18c712f099fd 100644
--- a/swift/stdlib/cmake/modules/AddSwiftStdlib.cmake
+++ b/swift/stdlib/cmake/modules/AddSwiftStdlib.cmake
@@ -1823,6 +1823,45 @@ endfunction()
 #   Presence of a build flavor requires SWIFT_MODULE_DEPENDS_MACCATALYST to be
 #   defined and have values.
 #
+# SWIFT_SOURCES_DEPENDS_MACOS
+#   Sources that are built when this library is being built for macOS
+#
+# SWIFT_SOURCES_DEPENDS_IOS
+#   Sources that are built when this library is being built for iOS
+#
+# SWIFT_SOURCES_DEPENDS_TVOS
+#   Sources that are built when this library is being built for tvOS
+#
+# SWIFT_SOURCES_DEPENDS_WATCHOS
+#   Sources that are built when this library is being built for watchOS
+#
+# SWIFT_SOURCES_DEPENDS_VISIONOS
+#   Sources that are built when this library is being built for visionOS
+#
+# SWIFT_SOURCES_DEPENDS_FREESTANDING
+#   Sources that are built when this library is being built for freestanding
+#
+# SWIFT_SOURCES_DEPENDS_FREEBSD
+#   Sources that are built when this library is being built for FreeBSD
+#
+# SWIFT_SOURCES_DEPENDS_OPENBSD
+#   Sources that are built when this library is being built for OpenBSD
+#
+# SWIFT_SOURCES_DEPENDS_LINUX
+#   Sources that are built when this library is being built for Linux
+#
+# SWIFT_SOURCES_DEPENDS_CYGWIN
+#   Sources that are built when this library is being built for Cygwin
+#
+# SWIFT_SOURCES_DEPENDS_HAIKU
+#   Sources that are built when this library is being built for Haiku
+#
+# SWIFT_SOURCES_DEPENDS_WASI
+#   Sources that are built when this library is being built for WASI
+#
+# SWIFT_SOURCES_DEPENDS_WINDOWS
+#   Sources that are built when this library is being built for Windows
+#
 # source1 ...
 #   Sources to add into this library.
 function(add_swift_target_library name)
@@ -1898,7 +1937,20 @@ function(add_swift_target_library name)
         TARGET_SDKS
         SWIFT_COMPILE_FLAGS_MACCATALYST
         SWIFT_MODULE_DEPENDS_MACCATALYST
-        SWIFT_MODULE_DEPENDS_MACCATALYST_UNZIPPERED)
+        SWIFT_MODULE_DEPENDS_MACCATALYST_UNZIPPERED
+        SWIFT_SOURCES_DEPENDS_MACOS
+        SWIFT_SOURCES_DEPENDS_IOS
+        SWIFT_SOURCES_DEPENDS_TVOS
+        SWIFT_SOURCES_DEPENDS_WATCHOS
+        SWIFT_SOURCES_DEPENDS_VISIONOS
+        SWIFT_SOURCES_DEPENDS_FREESTANDING
+        SWIFT_SOURCES_DEPENDS_FREEBSD
+        SWIFT_SOURCES_DEPENDS_OPENBSD
+        SWIFT_SOURCES_DEPENDS_LINUX
+        SWIFT_SOURCES_DEPENDS_CYGWIN
+        SWIFT_SOURCES_DEPENDS_HAIKU
+        SWIFT_SOURCES_DEPENDS_WASI
+        SWIFT_SOURCES_DEPENDS_WINDOWS)
 
   cmake_parse_arguments(SWIFTLIB
                         "${SWIFTLIB_options}"
@@ -2169,6 +2221,36 @@ function(add_swift_target_library name)
       list(APPEND swiftlib_link_flags_all "-Xlinker" "-ignore_auto_link")
     endif()
 
+    # Append SDK specific sources to the full list of sources
+    set(sources ${SWIFTLIB_SOURCES})
+    if(sdk STREQUAL "OSX")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_MACOS})
+    elseif(sdk STREQUAL "IOS" OR sdk STREQUAL "IOS_SIMULATOR")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_IOS})
+    elseif(sdk STREQUAL "TVOS" OR sdk STREQUAL "TVOS_SIMULATOR")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_TVOS})
+    elseif(sdk STREQUAL "WATCHOS" OR sdk STREQUAL "WATCHOS_SIMULATOR")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_WATCHOS})
+    elseif(sdk STREQUAL "XROS" OR sdk STREQUAL "XROS_SIMULATOR")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_VISIONOS})
+    elseif(sdk STREQUAL "FREESTANDING")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_FREESTANDING})
+    elseif(sdk STREQUAL "FREEBSD")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_FREEBSD})
+    elseif(sdk STREQUAL "OPENBSD")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_OPENBSD})
+    elseif(sdk STREQUAL "LINUX" OR sdk STREQUAL "ANDROID")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_LINUX})
+    elseif(sdk STREQUAL "CYGWIN")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_CYGWIN})
+    elseif(sdk STREQUAL "HAIKU")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_HAIKU})
+    elseif(sdk STREQUAL "WASI")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_WASI})
+    elseif(sdk STREQUAL "WINDOWS")
+      list(APPEND sources ${SWIFTLIB_SWIFT_SOURCES_DEPENDS_WINDOWS})
+    endif()
+
     # We unconditionally removed "-z,defs" from CMAKE_SHARED_LINKER_FLAGS in
     # swift_common_standalone_build_config_llvm within
     # SwiftSharedCMakeConfig.cmake, where it was added by a call to
@@ -2373,7 +2455,7 @@ function(add_swift_target_library name)
         ${SWIFTLIB_NO_LINK_NAME_keyword}
         ${SWIFTLIB_OBJECT_LIBRARY_keyword}
         ${SWIFTLIB_INSTALL_WITH_SHARED_keyword}
-        ${SWIFTLIB_SOURCES}
+        ${sources}
         MODULE_TARGETS ${module_variant_names}
         SDK ${sdk}
         ARCHITECTURE ${arch}
diff --git a/swift/stdlib/public/SwiftShims/swift/shims/CMakeLists.txt b/swift/stdlib/public/SwiftShims/swift/shims/CMakeLists.txt
index db995535938f2..65d815968faba 100644
--- a/swift/stdlib/public/SwiftShims/swift/shims/CMakeLists.txt
+++ b/swift/stdlib/public/SwiftShims/swift/shims/CMakeLists.txt
@@ -24,6 +24,7 @@ set(sources
   Visibility.h
   _SwiftConcurrency.h
   _SwiftDistributed.h
+  _SynchronizationShims.h
 
   module.modulemap
   )
diff --git a/swift/stdlib/public/SwiftShims/swift/shims/_SynchronizationShims.h b/swift/stdlib/public/SwiftShims/swift/shims/_SynchronizationShims.h
new file mode 100644
index 0000000000000..50fca8e39eca9
--- /dev/null
+++ b/swift/stdlib/public/SwiftShims/swift/shims/_SynchronizationShims.h
@@ -0,0 +1,69 @@
+//===----------------------------------------------------------------------===//
+//
+// This source file is part of the Swift.org open source project
+//
+// Copyright (c) 2024 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef SWIFT_STDLIB_SYNCHRONIZATION_SHIMS_H
+#define SWIFT_STDLIB_SYNCHRONIZATION_SHIMS_H
+
+#include "SwiftStdbool.h"
+#include "SwiftStdint.h"
+
+#if defined(__linux__)
+#include <errno.h>
+#include <linux/futex.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+static inline __swift_uint32_t _swift_stdlib_gettid() {
+  static __thread tid = 0;
+
+  if (tid == 0) {
+    tid = syscall(SYS_gettid);
+  }
+
+  return tid;
+}
+
+static inline __swift_uint32_t _swift_stdlib_futex_lock(__swift_uint32_t *lock) {
+  int ret = syscall(SYS_futex, lock, FUTEX_LOCK_PI_PRIVATE,
+                    /* val */ 0, // this value is ignored by this futex op
+                    /* timeout */ NULL); // block indefinitely
+
+  if (ret == 0) {
+    return ret;
+  }
+
+  return errno;
+}
+
+static inline __swift_uint32_t _swift_stdlib_futex_trylock(__swift_uint32_t *lock) {
+  int ret = syscall(SYS_futex, lock, FUTEX_TRYLOCK_PI);
+
+  if (ret == 0) {
+    return ret;
+  }
+
+  return errno;
+}
+
+static inline __swift_uint32_t _swift_stdlib_futex_unlock(__swift_uint32_t *lock) {
+  int ret = syscall(SYS_futex, lock, FUTEX_UNLOCK_PI_PRIVATE);
+
+  if (ret == 0) {
+    return ret;
+  }
+
+  return errno;
+}
+
+#endif // defined(__linux__)
+
+#endif // SWIFT_STDLIB_SYNCHRONIZATION_SHIMS_H
diff --git a/swift/stdlib/public/SwiftShims/swift/shims/module.modulemap b/swift/stdlib/public/SwiftShims/swift/shims/module.modulemap
index d2c11e3215f78..f6131a53c2ac2 100644
--- a/swift/stdlib/public/SwiftShims/swift/shims/module.modulemap
+++ b/swift/stdlib/public/SwiftShims/swift/shims/module.modulemap
@@ -31,3 +31,8 @@ module SwiftOverlayShims {
   header "LibcOverlayShims.h"
   export *
 }
+
+module _SynchronizationShims {
+  header "_SynchronizationShims.h"
+  export *
+}
diff --git a/swift/stdlib/public/Synchronization/Atomic.swift b/swift/stdlib/public/Synchronization/Atomics/Atomic.swift
similarity index 80%
rename from swift/stdlib/public/Synchronization/Atomic.swift
rename to swift/stdlib/public/Synchronization/Atomics/Atomic.swift
index f12482aecd27e..1f67c776fb78f 100644
--- a/swift/stdlib/public/Synchronization/Atomic.swift
+++ b/swift/stdlib/public/Synchronization/Atomics/Atomic.swift
@@ -21,14 +21,14 @@ public struct Atomic<Value: AtomicRepresentable>: ~Copyable {
   @available(SwiftStdlib 6.0, *)
   @_alwaysEmitIntoClient
   @_transparent
-  var address: UnsafeMutablePointer<Value.AtomicRepresentation> {
-    UnsafeMutablePointer<Value.AtomicRepresentation>(rawAddress)
+  var _address: UnsafeMutablePointer<Value.AtomicRepresentation> {
+    UnsafeMutablePointer<Value.AtomicRepresentation>(_rawAddress)
   }
 
   @available(SwiftStdlib 6.0, *)
   @_alwaysEmitIntoClient
   @_transparent
-  var rawAddress: Builtin.RawPointer {
+  var _rawAddress: Builtin.RawPointer {
     Builtin.unprotectedAddressOfBorrow(self)
   }
 
@@ -39,7 +39,7 @@ public struct Atomic<Value: AtomicRepresentable>: ~Copyable {
   @_alwaysEmitIntoClient
   @_transparent
   public init(_ initialValue: consuming Value) {
-    address.initialize(to: Value.encodeAtomicRepresentation(initialValue))
+    _address.initialize(to: Value.encodeAtomicRepresentation(initialValue))
   }
 
   // Deinit's can't be marked @_transparent. Do these things need all of these
@@ -48,10 +48,10 @@ public struct Atomic<Value: AtomicRepresentable>: ~Copyable {
   @_alwaysEmitIntoClient
   @inlinable
   deinit {
-    let oldValue = Value.decodeAtomicRepresentation(address.pointee)
+    let oldValue = Value.decodeAtomicRepresentation(_address.pointee)
     _ = consume oldValue
 
-    address.deinitialize(count: 1)
+    _address.deinitialize(count: 1)
   }
 }
 
diff --git a/swift/stdlib/public/Synchronization/AtomicBool.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicBool.swift
similarity index 95%
rename from swift/stdlib/public/Synchronization/AtomicBool.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicBool.swift
index b12e8fef4f3e4..34f30469d136b 100644
--- a/swift/stdlib/public/Synchronization/AtomicBool.swift
+++ b/swift/stdlib/public/Synchronization/Atomics/AtomicBool.swift
@@ -93,31 +93,31 @@ extension Atomic where Value == Bool {
     let original = switch ordering {
     case .relaxed:
       Builtin.atomicrmw_and_monotonic_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .acquiring:
       Builtin.atomicrmw_and_acquire_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .releasing:
       Builtin.atomicrmw_and_release_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .acquiringAndReleasing:
       Builtin.atomicrmw_and_acqrel_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .sequentiallyConsistent:
       Builtin.atomicrmw_and_seqcst_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
@@ -151,31 +151,31 @@ extension Atomic where Value == Bool {
     let original = switch ordering {
     case .relaxed:
       Builtin.atomicrmw_or_monotonic_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .acquiring:
       Builtin.atomicrmw_or_acquire_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .releasing:
       Builtin.atomicrmw_or_release_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .acquiringAndReleasing:
       Builtin.atomicrmw_or_acqrel_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .sequentiallyConsistent:
       Builtin.atomicrmw_or_seqcst_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
@@ -209,31 +209,31 @@ extension Atomic where Value == Bool {
     let original = switch ordering {
     case .relaxed:
       Builtin.atomicrmw_xor_monotonic_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .acquiring:
       Builtin.atomicrmw_xor_acquire_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .releasing:
       Builtin.atomicrmw_xor_release_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .acquiringAndReleasing:
       Builtin.atomicrmw_xor_acqrel_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
     case .sequentiallyConsistent:
       Builtin.atomicrmw_xor_seqcst_Int8(
-        rawAddress,
+        _rawAddress,
         builtinOperand
       )
 
diff --git a/swift/stdlib/public/Synchronization/AtomicFloats.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicFloats.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/AtomicFloats.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicFloats.swift
diff --git a/swift/stdlib/public/Synchronization/AtomicIntegers.swift.gyb b/swift/stdlib/public/Synchronization/Atomics/AtomicIntegers.swift.gyb
similarity index 99%
rename from swift/stdlib/public/Synchronization/AtomicIntegers.swift.gyb
rename to swift/stdlib/public/Synchronization/Atomics/AtomicIntegers.swift.gyb
index b13d19dec1ccd..32ea1b7f0212d 100644
--- a/swift/stdlib/public/Synchronization/AtomicIntegers.swift.gyb
+++ b/swift/stdlib/public/Synchronization/Atomics/AtomicIntegers.swift.gyb
@@ -120,12 +120,12 @@ extension Atomic where Value == ${intType} {
 %     if intType == "Int" or intType == "UInt":
 #if _pointerBitWidth(_64)
       Builtin.atomicrmw_${atomicOperationName(intType, builtinName)}_${llvmOrder}_Int64(
-        rawAddress,
+        _rawAddress,
         operand._value
       )
 #elseif _pointerBitWidth(_32)
       Builtin.atomicrmw_${atomicOperationName(intType, builtinName)}_${llvmOrder}_Int32(
-        rawAddress,
+        _rawAddress,
         operand._value
       )
 #else
@@ -133,7 +133,7 @@ extension Atomic where Value == ${intType} {
 #endif
 %     else:
       Builtin.atomicrmw_${atomicOperationName(intType, builtinName)}_${llvmOrder}_Int${bits}(
-        rawAddress,
+        _rawAddress,
         operand._value
       )
 %     end
diff --git a/swift/stdlib/public/Synchronization/AtomicLazyReference.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicLazyReference.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/AtomicLazyReference.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicLazyReference.swift
diff --git a/swift/stdlib/public/Synchronization/AtomicMemoryOrderings.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicMemoryOrderings.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/AtomicMemoryOrderings.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicMemoryOrderings.swift
diff --git a/swift/stdlib/public/Synchronization/AtomicOptional.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicOptional.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/AtomicOptional.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicOptional.swift
diff --git a/swift/stdlib/public/Synchronization/AtomicPointers.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicPointers.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/AtomicPointers.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicPointers.swift
diff --git a/swift/stdlib/public/Synchronization/AtomicRepresentable.swift b/swift/stdlib/public/Synchronization/Atomics/AtomicRepresentable.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/AtomicRepresentable.swift
rename to swift/stdlib/public/Synchronization/Atomics/AtomicRepresentable.swift
diff --git a/swift/stdlib/public/Synchronization/AtomicStorage.swift.gyb b/swift/stdlib/public/Synchronization/Atomics/AtomicStorage.swift.gyb
similarity index 98%
rename from swift/stdlib/public/Synchronization/AtomicStorage.swift.gyb
rename to swift/stdlib/public/Synchronization/Atomics/AtomicStorage.swift.gyb
index 91e5ff065095e..a0779b7e54f18 100644
--- a/swift/stdlib/public/Synchronization/AtomicStorage.swift.gyb
+++ b/swift/stdlib/public/Synchronization/Atomics/AtomicStorage.swift.gyb
@@ -53,7 +53,7 @@ extension Atomic where Value.AtomicRepresentation == ${type} {
     let result = switch ordering {
 %   for (name, api, doc, llvm) in loadOrderings:
     case .${name}:
-      Builtin.atomicload_${llvm}_Int${size}(rawAddress)
+      Builtin.atomicload_${llvm}_Int${size}(_rawAddress)
 %   end
 
     default:
@@ -87,7 +87,7 @@ extension Atomic where Value.AtomicRepresentation == ${type} {
 %   for (name, api, doc, llvm) in storeOrderings:
     case .${name}:
       Builtin.atomicstore_${llvm}_Int${size}(
-        rawAddress,
+        _rawAddress,
         Value.encodeAtomicRepresentation(desired)._storage
       )
 %   end
@@ -123,7 +123,7 @@ extension Atomic where Value.AtomicRepresentation == ${type} {
     let result = switch ordering {
 %   for (name, api, _, llvm, _) in updateOrderings:
     case .${name}:
-      Builtin.atomicrmw_xchg_${llvm}_Int${size}(rawAddress, desired)
+      Builtin.atomicrmw_xchg_${llvm}_Int${size}(_rawAddress, desired)
 %   end
 
     default:
@@ -229,7 +229,7 @@ extension Atomic where Value.AtomicRepresentation == ${type} {
 %     for (failureName, _, _, failureLLVM) in loadOrderings:
     case (.${successName}, .${failureName}):
       Builtin.cmpxchg_${actualOrders(successLLVM, failureLLVM)}_Int${size}(
-        rawAddress,
+        _rawAddress,
         expected,
         desired
       )
@@ -359,7 +359,7 @@ extension Atomic where Value.AtomicRepresentation == ${type} {
 %     for (failureName, _, _, failureLLVM) in loadOrderings:
     case (.${successName}, .${failureName}):
       Builtin.cmpxchg_${actualOrders(successLLVM, failureLLVM)}_weak_Int${size}(
-        rawAddress,
+        _rawAddress,
         expected,
         desired
       )
diff --git a/swift/stdlib/public/Synchronization/WordPair.swift b/swift/stdlib/public/Synchronization/Atomics/WordPair.swift
similarity index 100%
rename from swift/stdlib/public/Synchronization/WordPair.swift
rename to swift/stdlib/public/Synchronization/Atomics/WordPair.swift
diff --git a/swift/stdlib/public/Synchronization/CMakeLists.txt b/swift/stdlib/public/Synchronization/CMakeLists.txt
index 7a1de4db90eea..9d9ec0524cd2a 100644
--- a/swift/stdlib/public/Synchronization/CMakeLists.txt
+++ b/swift/stdlib/public/Synchronization/CMakeLists.txt
@@ -10,32 +10,110 @@
 #
 #===----------------------------------------------------------------------===#
 
-set(swift_synchronization_sources
-  Atomic.swift
-  AtomicBool.swift
-  AtomicFloats.swift
-  AtomicLazyReference.swift
-  AtomicMemoryOrderings.swift
-  AtomicOptional.swift
-  AtomicPointers.swift
-  AtomicRepresentable.swift
-  WordPair.swift
+set(SWIFT_SYNCHRONIZATION_ATOMIC_SOURCES
+  Atomics/Atomic.swift
+  Atomics/AtomicBool.swift
+  Atomics/AtomicFloats.swift
+  Atomics/AtomicLazyReference.swift
+  Atomics/AtomicMemoryOrderings.swift
+  Atomics/AtomicOptional.swift
+  Atomics/AtomicPointers.swift
+  Atomics/AtomicRepresentable.swift
+  Atomics/WordPair.swift
 )
-set(swift_synchronization_gyb_sources
-  AtomicIntegers.swift.gyb
-  AtomicStorage.swift.gyb
+
+set(SWIFT_SYNCHRONIZATION_SOURCES
+  ${SWIFT_SYNCHRONIZATION_ATOMIC_SOURCES}
+
+  Cell.swift
+)
+
+set(SWIFT_SYNCHRONIZATION_GYB_SOURCES
+  Atomics/AtomicIntegers.swift.gyb
+  Atomics/AtomicStorage.swift.gyb
 )
-set(swift_synchronization_swift_compile_flags
+
+# Darwin sources
+
+set(SWIFT_SYNCHRONIZATION_DARWIN_SOURCES
+  Mutex/DarwinImpl.swift
+  Mutex/Mutex.swift
+)
+
+# Linux and Android sources
+
+set(SWIFT_SYNCHRONIZATION_LINUX_SOURCES
+  Mutex/LinuxImpl.swift
+  Mutex/Mutex.swift
+  Mutex/SpinLoopHint.swift
+)
+
+# Wasm sources
+
+set(SWIFT_SYNCHRONIZATION_WASM_SOURCES
+  Mutex/Mutex.swift
+  Mutex/WasmImpl.swift
+)
+
+# Windows sources
+
+set(SWIFT_SYNCHRONIZATION_WINDOWS_SOURCES
+  Mutex/Mutex.swift
+  Mutex/WindowsImpl.swift
+)
+
+set(SWIFT_SYNCHRNOIZATION_SWIFT_FLAGS
   ${SWIFT_STANDARD_LIBRARY_SWIFT_FLAGS}
   "-enable-builtin-module"
   "-enable-experimental-feature" "RawLayout"
   "-enable-experimental-feature" "StaticExclusiveOnly"
+  "-enable-experimental-feature" "Extern"
 )
 
 add_swift_target_library(swiftSynchronization ${SWIFT_STDLIB_LIBRARY_BUILD_TYPES} IS_STDLIB
-  ${swift_synchronization_sources}
-  GYB_SOURCES ${swift_synchronization_gyb_sources}
-  SWIFT_COMPILE_FLAGS ${swift_synchronization_swift_compile_flags}
+  ${SWIFT_SYNCHRONIZATION_SOURCES}
+
+  GYB_SOURCES
+    ${SWIFT_SYNCHRONIZATION_GYB_SOURCES}
+
+  SWIFT_SOURCES_DEPENDS_MACOS
+    ${SWIFT_SYNCHRONIZATION_DARWIN_SOURCES}
+  SWIFT_SOURCES_DEPENDS_IOS
+    ${SWIFT_SYNCHRONIZATION_DARWIN_SOURCES}
+  SWIFT_SOURCES_DEPENDS_TVOS
+    ${SWIFT_SYNCHRONIZATION_DARWIN_SOURCES}
+  SWIFT_SOURCES_DEPENDS_WATCHOS
+    ${SWIFT_SYNCHRONIZATION_DARWIN_SOURCES}
+  SWIFT_SOURCES_DEPENDS_VISIONOS
+    ${SWIFT_SYNCHRONIZATION_DARWIN_SOURCES}
+  SWIFT_SOURCES_DEPENDS_LINUX
+    ${SWIFT_SYNCHRONIZATION_LINUX_SOURCES}
+  SWIFT_SOURCES_DEPENDS_WASI
+    ${SWIFT_SYNCHRONIZATION_WASM_SOURCES}
+  SWIFT_SOURCES_DEPENDS_WINDOWS
+    ${SWIFT_SYNCHRONIZATION_WINDOWS_SOURCES}
+  SWIFT_SOURCES_DEPENDS_FREESTANDING
+    Mutex/MutexUnavailable.swift
+
+  SWIFT_MODULE_DEPENDS_OSX
+    Darwin
+  SWIFT_MODULE_DEPENDS_IOS
+    Darwin
+  SWIFT_MODULE_DEPENDS_TVOS
+    Darwin
+  SWIFT_MODULE_DEPENDS_WATCHOS
+    Darwin
+  SWIFT_MODULE_DEPENDS_XROS
+    Darwin
+  SWIFT_MODULE_DEPENDS_LINUX
+    Glibc
+  SWIFT_MODULE_DEPENDS_ANDROID
+    Android
+  SWIFT_MODULE_DEPENDS_WINDOWS
+    WinSDK
+
+  SWIFT_COMPILE_FLAGS
+    ${SWIFT_SYNCHRNOIZATION_SWIFT_FLAGS}
   LINK_FLAGS
     "${SWIFT_RUNTIME_SWIFT_LINK_FLAGS}"
   INSTALL_IN_COMPONENT
@@ -68,11 +146,12 @@ if(SWIFT_SHOULD_BUILD_EMBEDDED_STDLIB)
       ONLY_SWIFTMODULE
       IS_FRAGILE
       
-      ${swift_synchronization_sources}
-      GYB_SOURCES ${swift_synchronization_gyb_sources}
+      ${SWIFT_SYNCHRONIZATION_ATOMIC_SOURCES}
+      GYB_SOURCES
+        ${SWIFT_SYNCHRONIZATION_GYB_SOURCES}
 
       SWIFT_COMPILE_FLAGS
-        ${swift_synchronization_swift_compile_flags}
+        ${SWIFT_SYNCHRNOIZATION_SWIFT_FLAGS}
         -Xcc -D__MACH__ -Xcc -D__APPLE__ -Xcc -ffreestanding -enable-experimental-feature Embedded
 
       MODULE_DIR "${CMAKE_BINARY_DIR}/lib/swift/embedded"
diff --git a/swift/stdlib/public/Synchronization/Cell.swift b/swift/stdlib/public/Synchronization/Cell.swift
new file mode 100644
index 0000000000000..c893952004782
--- /dev/null
+++ b/swift/stdlib/public/Synchronization/Cell.swift
@@ -0,0 +1,51 @@
+//===----------------------------------------------------------------------===//
+//
+// This source file is part of the Swift Atomics open source project
+//
+// Copyright (c) 2024 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+import Builtin
+
+@available(SwiftStdlib 6.0, *)
+@frozen
+@usableFromInline
+@_rawLayout(like: Value, movesAsLike)
+internal struct _Cell<Value: ~Copyable>: ~Copyable {
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal var _address: UnsafeMutablePointer<Value> {
+    UnsafeMutablePointer<Value>(_rawAddress)
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal var _rawAddress: Builtin.RawPointer {
+#if $BuiltinAddressOfRawLayout
+    Builtin.addressOfRawLayout(self)
+#else
+    fatalError()
+#endif
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal init(_ initialValue: consuming Value) {
+    _address.initialize(to: initialValue)
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @inlinable
+  deinit {
+    _address.deinitialize(count: 1)
+  }
+}
diff --git a/swift/stdlib/public/Synchronization/Mutex/DarwinImpl.swift b/swift/stdlib/public/Synchronization/Mutex/DarwinImpl.swift
new file mode 100644
index 0000000000000..7b0afef515542
--- /dev/null
+++ b/swift/stdlib/public/Synchronization/Mutex/DarwinImpl.swift
@@ -0,0 +1,49 @@
+//===----------------------------------------------------------------------===//
+//
+// This source file is part of the Swift Atomics open source project
+//
+// Copyright (c) 2024 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+import Darwin
+
+@available(SwiftStdlib 6.0, *)
+@frozen
+@_staticExclusiveOnly
+public struct _MutexHandle: ~Copyable {
+  @usableFromInline
+  let value: _Cell<os_unfair_lock>
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public init() {
+    value = _Cell(os_unfair_lock())
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal borrowing func _lock() {
+    os_unfair_lock_lock(value._address)
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal borrowing func _tryLock() -> Bool {
+    os_unfair_lock_trylock(value._address)
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal borrowing func _unlock() {
+    os_unfair_lock_unlock(value._address)
+  }
+}
diff --git a/swift/stdlib/public/Synchronization/Mutex/Mutex.swift b/swift/stdlib/public/Synchronization/Mutex/Mutex.swift
new file mode 100644
index 0000000000000..ea91b4d452513
--- /dev/null
+++ b/swift/stdlib/public/Synchronization/Mutex/Mutex.swift
@@ -0,0 +1,195 @@
+//===----------------------------------------------------------------------===//
+//
+// This source file is part of the Swift Atomics open source project
+//
+// Copyright (c) 2024 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+/// A synchronization primitive that protects shared mutable state via
+/// mutual exclusion.
+///
+/// The `Mutex` type offers non-recursive exclusive access to the state
+/// it is protecting by blocking threads attempting to acquire the lock.
+/// Only one execution context at a time has access to the value stored
+/// within the `Mutex` allowing for exclusive access.
+///
+/// An example use of `Mutex` in a class used simultaneously by many
+/// threads protecting a `Dictionary` value:
+///
+///     class Manager {
+///       let cache = Mutex<[Key: Resource]>([:])
+///
+///       func saveResouce(_ resource: Resouce, as key: Key) {
+///         cache.withLock {
+///           $0[key] = resource
+///         }
+///       }
+///     }
+///
+@available(SwiftStdlib 6.0, *)
+@frozen
+@_staticExclusiveOnly
+public struct Mutex<Value: ~Copyable>: ~Copyable {
+  @usableFromInline
+  let handle = _MutexHandle()
+
+  @usableFromInline
+  let value: _Cell<Value>
+
+  /// Initializes a value of this mutex with the given initial state.
+  ///
+  /// - Parameter initialValue: The initial value to give to the mutex.
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public init(_ initialValue: consuming sending Value) {
+    value = _Cell(initialValue)
+  }
+}
+
+@available(SwiftStdlib 6.0, *)
+extension Mutex: @unchecked Sendable where Value: ~Copyable {}
+
+@available(SwiftStdlib 6.0, *)
+extension Mutex where Value: ~Copyable {
+  /// Calls the given closure after acquring the lock and then releases
+  /// ownership.
+  ///
+  /// This method is equivalent to the following sequence of code:
+  ///
+  ///     mutex.lock()
+  ///     defer {
+  ///       mutex.unlock()
+  ///     }
+  ///     return try body(&value)
+  ///
+  /// - Warning: Recursive calls to `withLock` within the
+  ///   closure parameter has behavior that is platform dependent.
+  ///   Some platforms may choose to panic the process, deadlock,
+  ///   or leave this behavior unspecified. This will never
+  ///   reacquire the lock however.
+  ///
+  /// - Parameter body: A closure with a parameter of `Value`
+  ///   that has exclusive access to the value being stored within
+  ///   this mutex. This closure is considered the critical section
+  ///   as it will only be executed once the calling thread has
+  ///   acquired the lock.
+  ///
+  /// - Returns: The return value, if any, of the `body` closure parameter.
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func withLock<Result: ~Copyable, E: Error>(
+    _ body: @Sendable (inout Value) throws(E) -> sending Result
+  ) throws(E) -> sending Result {
+    handle._lock()
+
+    defer {
+      handle._unlock()
+    }
+
+    return try body(&value._address.pointee)
+  }
+
+  /// Attempts to acquire the lock and then calls the given closure if
+  /// successful.
+  ///
+  /// If the calling thread was successful in acquiring the lock, the
+  /// closure will be executed and then immediately after it will
+  /// release ownership of the lock. If we were unable to acquire the
+  /// lock, this will return `nil`.
+  ///
+  /// This method is equivalent to the following sequence of code:
+  ///
+  ///     guard mutex.tryLock() else {
+  ///       return nil
+  ///     }
+  ///     defer {
+  ///       mutex.unlock()
+  ///     }
+  ///     return try body(&value)
+  ///
+  /// - Warning: Recursive calls to `withLockIfAvailable` within the
+  ///   closure parameter has behavior that is platform dependent.
+  ///   Some platforms may choose to panic the process, deadlock,
+  ///   or leave this behavior unspecified. This will never
+  ///   reacquire the lock however.
+  ///
+  /// - Parameter body: A closure with a parameter of `Value`
+  ///   that has exclusive access to the value being stored within
+  ///   this mutex. This closure is considered the critical section
+  ///   as it will only be executed if the calling thread acquires
+  ///   the lock.
+  ///
+  /// - Returns: The return value, if any, of the `body` closure parameter
+  ///   or nil if the lock couldn't be acquired.
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func withLockIfAvailable<Result: ~Copyable, E: Error>(
+    _ body: @Sendable (inout Value) throws(E) -> sending Result
+  ) throws(E) -> sending Result? {
+    guard handle._tryLock() else {
+      return nil
+    }
+
+    defer {
+      handle._unlock()
+    }
+
+    return try body(&value._address.pointee)
+  }
+}
+
+@available(SwiftStdlib 6.0, *)
+extension Mutex where Value == Void {
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func _unsafeLock() {
+    handle._lock()
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func _unsafeTryLock() -> Bool {
+    handle._tryLock()
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func _unsafeUnlock() {
+    handle._unlock()
+  }
+}
+
+@available(SwiftStdlib 6.0, *)
+extension _MutexHandle {
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func unsafeLock() {
+    _lock()
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func unsafeTryLock() -> Bool {
+    _tryLock()
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public borrowing func unsafeUnlock() {
+    _unlock()
+  }
+}
diff --git a/swift/stdlib/public/Synchronization/Mutex/SpinLoopHint.swift b/swift/stdlib/public/Synchronization/Mutex/SpinLoopHint.swift
new file mode 100644
index 0000000000000..940310f4fb4a6
--- /dev/null
+++ b/swift/stdlib/public/Synchronization/Mutex/SpinLoopHint.swift
@@ -0,0 +1,67 @@
+//===----------------------------------------------------------------------===//
+//
+// This source file is part of the Swift Atomics open source project
+//
+// Copyright (c) 2024 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+#if arch(arm) || arch(arm64) || arch(arm64_32)
+
+@inline(__always)
+var _tries: Int {
+  100
+}
+
+// The following are acceptable operands to the aarch64 hint intrinsic from
+// 'llvm-project/llvm/lib/Target/ARM/ARMInstrInfo.td':
+//
+// `nop`   = 0
+// `yield` = 1
+// `wfe`   = 2
+// `wfi`   = 3
+// `sev`   = 4
+// `sevl`  = 5
+//
+// There are others, but for the sake of spin loops, we only care about 'wfe'.
+@_extern(c, "llvm.aarch64.hint")
+func _hint(_: UInt32)
+
+@inline(__always)
+func _wfe() {
+  _hint(2)
+}
+
+#elseif arch(i386) || arch(x86_64)
+
+@inline(__always)
+var _tries: Int {
+  1000
+}
+
+@_extern(c, "llvm.x86.sse2.pause")
+func _pause()
+
+#else
+
+@inline(__always)
+var _tries: Int {
+  100
+}
+
+#endif
+
+@inline(__always)
+func _spinLoopHint() {
+#if arch(arm) || arch(arm64) || arch(arm64_32)
+  _wfe()
+#elseif arch(i386) || arch(x86_64)
+  _pause()
+#else
+  // Just do a nop on architectures we don't know about.
+#endif
+}
diff --git a/swift/stdlib/public/Synchronization/Mutex/WindowsImpl.swift b/swift/stdlib/public/Synchronization/Mutex/WindowsImpl.swift
new file mode 100644
index 0000000000000..e97072b35c7a7
--- /dev/null
+++ b/swift/stdlib/public/Synchronization/Mutex/WindowsImpl.swift
@@ -0,0 +1,50 @@
+//===----------------------------------------------------------------------===//
+//
+// This source file is part of the Swift Atomics open source project
+//
+// Copyright (c) 2024 Apple Inc. and the Swift project authors
+// Licensed under Apache License v2.0 with Runtime Library Exception
+//
+// See https://swift.org/LICENSE.txt for license information
+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
+//
+//===----------------------------------------------------------------------===//
+
+import WinSDK.core.synch
+
+@available(SwiftStdlib 6.0, *)
+@frozen
+@_staticExclusiveOnly
+public struct _MutexHandle: ~Copyable {
+  @usableFromInline
+  let value: _Cell<SRWLOCK>
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  public init() {
+    value = _Cell(SRWLOCK())
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal borrowing func _lock() {
+    AcquireSRWLockExclusive(value._address)
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal borrowing func _tryLock() -> Bool {
+    // Windows BOOLEAN gets imported as 'UInt8'...
+    TryAcquireSRWLockExclusive(value._address) != 0
+  }
+
+  @available(SwiftStdlib 6.0, *)
+  @_alwaysEmitIntoClient
+  @_transparent
+  internal borrowing func _unlock() {
+    ReleaseSRWLockExclusive(value._address)
+  }
+}
